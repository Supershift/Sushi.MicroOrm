using Microsoft.Data.SqlClient;
using Sushi.MicroORM.Mapping;
using Sushi.MicroORM.Supporting;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Reflection;
using System.Threading;
using System.Threading.Tasks;

namespace Sushi.MicroORM
{
    /// <summary>
    /// Retrieves database records and returns them as objects, based on provided mapping.
    /// </summary>
    /// <typeparam name="T">Type to convert database recrods to</typeparam>
    public class Connector<T> where T : new()
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Connector{T}"/> class.
        /// </summary>
        public Connector() : this(null, null) { }

        /// <summary>
        /// Initializes a new instance of the <see cref="Connector{T}"/> class, using <paramref name="connectionString"/> instead of the default connection string for <typeparamref name="T"/>.
        /// </summary>
        public Connector(string connectionString) : this(connectionString, null) { }

        /// <summary>
        /// Initializes a new instance of the <see cref="Connector{T}"/> class, using <paramref name="map"/> instead of the default map for <typeparamref name="T"/>.
        /// </summary>
        public Connector(DataMap<T> map) : this(null, map) { }

        /// <summary>
        /// Initializes a new instance of the <see cref="Connector{T}"/> class, using <paramref name="connectionString"/> and <paramref name="map"/> instead of the default connection string and map for <typeparamref name="T"/>.
        /// </summary>
        public Connector(string connectionString, DataMap<T> map)
        {
            if(map == null)                
                map = DatabaseConfiguration.DataMapProvider.GetMapForType<T>() as DataMap<T>;

            Map = map;
            if (Map == null)
                throw new Exception($"No mapping defined for class {typeof(T)}");

            if (!string.IsNullOrWhiteSpace(connectionString))
                ConnectionString = connectionString;
        }

        /// <summary>
        /// Gets or sets the wait time in seconds before terminating the attempt to execute a command and generating an error.
        /// </summary>
        public int? CommandTimeout { get; set; }

        private string _ConnectionString;
        /// <summary>
        /// Gets the connection string used to connect to the database
        /// </summary>
        public string ConnectionString
        {
            get
            {
                if (string.IsNullOrWhiteSpace(_ConnectionString))
                    _ConnectionString = DatabaseConfiguration.ConnectionStringProvider.GetConnectionString(typeof(T));
                return _ConnectionString;
            }
            set
            {
                _ConnectionString = value;
            }
        }

        /// <summary>
        /// Gets an object representing the mapping between <typeparamref name="T"/> and database.
        /// </summary>
        public DataMap<T> Map { get; protected set; }

        /// <summary>
        /// Gets or sets the behavior for connector's FetchSingle methods in case a record is not found in the database.         
        /// </summary>
        public FetchSingleMode FetchSingleMode { get; set; } = FetchSingleMode.ReturnDefaultWhenNotFound;

        /// <summary>
        /// Creates a new instance of <see cref="DataQuery{T}"/>. Use the constructor of Dataquery for more control when creating a Dataquery.
        /// </summary>
        /// <returns></returns>
        [Obsolete("Use CreateQuery instead")]
        public DataQuery<T> CreateDataFilter()
        {
            return new DataQuery<T>(Map);
        }

        /// <summary>
        /// Creates a new instance of <see cref="DataQuery{T}"/>. 
        /// </summary>
        /// <returns></returns>
        public DataQuery<T> CreateQuery()
        {
            return new DataQuery<T>(Map);
        }

        /// <summary>
        /// Executes the <paramref name="statement"/> and returns the result generated by the execution.
        /// </summary>
        /// <param name="statement"></param>
        /// <returns></returns>
        public virtual SqlStatementResult<TResult> ExecuteSqlStatement<TResult>(SqlStatement<T> statement) 
        {
            SqlStatementResult<TResult> result;
            //perform a callback here?
            using (var sqlCommander = new SqlCommander(ConnectionString, CommandTimeout))
            {
                //apply sql statement to sql commander
                sqlCommander.SqlText = statement.GenerateSqlStatement();
                
                //add parameters
                foreach(var parameter in statement.Parameters)                
                    sqlCommander.SetParameterInput(parameter.Name, parameter.Value, parameter.Type, parameter.Length, parameter.TypeName);

                //execute the statement
                SqlDataReader reader = null;
                
                try
                {
                    switch(statement.ResultCardinality)
                    {                        
                        case SqlStatementResultCardinality.SingleRow:
                            //execute the command, which will return a reader
                            reader = sqlCommander.ExecReader();
                            //if the result type of the statement is the same, or inherits, the mapped type T, use the map to create a result object
                            if(typeof(TResult) == typeof(T) || typeof(TResult).IsSubclassOf(typeof(T)))
                            {
                                var singleResult = ResultMapper.MapToSingleResult(reader, Map, FetchSingleMode);
                                result = new SqlStatementResult<TResult>((TResult)(object)singleResult);
                            }
                            else
                            {
                                //create a single (scalar) result
                                var scalarResult = ResultMapper.MapToSingleResultScalar<TResult>(reader);
                                result = new SqlStatementResult<TResult>(scalarResult);
                            }
                            break;
                        case SqlStatementResultCardinality.MultipleRows:
                            //execute the command, which will return a reader
                            reader = sqlCommander.ExecReader();
                            //if the result type of the statement is the same, or inherits, the mapped type T, use the map to create a result object
                            if (typeof(TResult) == typeof(T) || typeof(TResult).IsSubclassOf(typeof(T)))
                            {
                                //map the contents of the reader to a result
                                var multipleResults = ResultMapper.MapToMultipleResults(reader, Map);
                                //cast to TResult
                                var castedResults = multipleResults.Select(x => (TResult)(object)x).ToList();

                                //check if there is a 2nd result set with total number of rows for paging
                                int? numberOfRows = null;

                                if(reader.NextResult())
                                {
                                    numberOfRows = ResultMapper.MapToSingleResultScalar<int?>(reader);
                                }

                                result = new SqlStatementResult<TResult>(castedResults, numberOfRows);
                            }
                            else
                            {
                                var multipleResults = ResultMapper.MapToMultipleResultsScalar<TResult>(reader);
                                //check if there is a 2nd result set with total number of rows for paging
                                int? numberOfRows = null;

                                if (reader.NextResult())
                                {
                                    numberOfRows = ResultMapper.MapToSingleResultScalar<int?>(reader);
                                }

                                result = new SqlStatementResult<TResult>(multipleResults, numberOfRows);
                            }
                            break;                        
                        case SqlStatementResultCardinality.None:
                            //execute the command
                            sqlCommander.ExecNonQuery();
                            result = new SqlStatementResult<TResult>();
                            break;
                        default:
                            throw new NotImplementedException();
                    }
                }
                finally
                {
                    if (reader != null)
                        reader.Close();
                }                
            }
            //perform a callback here?
            return result;
        }

        /// <summary>
        /// Executes the <paramref name="statement"/> and returns the result generated by the execution.
        /// </summary>        
        /// <returns></returns>
        public virtual async Task<SqlStatementResult<TResult>> ExecuteSqlStatementAsync<TResult>(SqlStatement<T> statement, CancellationToken cancellationToken)
        {
            SqlStatementResult<TResult> result;
            //perform a callback here?
            using (var sqlCommander = new SqlCommander(ConnectionString, CommandTimeout))
            {
                //apply sql statement to sql commander
                sqlCommander.SqlText = statement.GenerateSqlStatement();

                //add parameters
                foreach (var parameter in statement.Parameters)
                    sqlCommander.SetParameterInput(parameter.Name, parameter.Value, parameter.Type, parameter.Length, parameter.TypeName);

                //execute the statement
                SqlDataReader reader = null;

                try
                {
                    switch (statement.ResultCardinality)
                    {
                        case SqlStatementResultCardinality.SingleRow:
                            //execute the command, which will return a reader
                            reader = await sqlCommander.ExecReaderAsync(cancellationToken).ConfigureAwait(false);
                            //if the result type of the statement is the same, or inherits, the mapped type T, use the map to create a result object
                            if (typeof(TResult) == typeof(T) || typeof(TResult).IsSubclassOf(typeof(T)))
                            {
                                var singleResult = await ResultMapperAsync.MapToSingleResultAsync(reader, Map, FetchSingleMode, cancellationToken).ConfigureAwait(false);
                                result = new SqlStatementResult<TResult>((TResult)(object)singleResult);
                            }
                            else
                            {
                                //create a single (scalar) result
                                var scalarResult = await ResultMapperAsync.MapToSingleResultScalarAsync<TResult>(reader, cancellationToken).ConfigureAwait(false);
                                result = new SqlStatementResult<TResult>(scalarResult);
                            }
                            break;
                        case SqlStatementResultCardinality.MultipleRows:
                            //execute the command, which will return a reader
                            reader = await sqlCommander.ExecReaderAsync(cancellationToken).ConfigureAwait(false);
                            //if the result type of the statement is the same, or inherits, the mapped type T, use the map to create a result object
                            if (typeof(TResult) == typeof(T) || typeof(TResult).IsSubclassOf(typeof(T)))
                            {
                                //map the contents of the reader to a result
                                var multipleResults = await ResultMapperAsync.MapToMultipleResultsAsync(reader, Map, cancellationToken).ConfigureAwait(false);
                                //cast to TResult
                                var castedResults = multipleResults.Select(x => (TResult)(object)x).ToList();

                                //check if there is a 2nd result set with total number of rows for paging
                                int? numberOfRows = null;

                                if (reader.NextResult())
                                {
                                    numberOfRows = await ResultMapperAsync.MapToSingleResultScalarAsync<int?>(reader, cancellationToken).ConfigureAwait(false);
                                }

                                result = new SqlStatementResult<TResult>(castedResults, numberOfRows);
                            }
                            else
                            {
                                var multipleResults = await ResultMapperAsync.MapToMultipleResultsScalarAsync<TResult>(reader, cancellationToken).ConfigureAwait(false);
                                //check if there is a 2nd result set with total number of rows for paging
                                int? numberOfRows = null;

                                if (reader.NextResult())
                                {
                                    numberOfRows = await ResultMapperAsync.MapToSingleResultScalarAsync<int?>(reader, cancellationToken).ConfigureAwait(false);
                                }

                                result = new SqlStatementResult<TResult>(multipleResults, numberOfRows);
                            }
                            break;
                        case SqlStatementResultCardinality.None:
                            //execute the command
                            await sqlCommander.ExecNonQueryAsync(cancellationToken).ConfigureAwait(false);
                            result = new SqlStatementResult<TResult>();
                            break;
                        default:
                            throw new NotImplementedException();
                    }
                }
                finally
                {
                    if (reader != null)
                        reader.Close();
                }
            }
            //perform a callback here?
            return result;
        }

        internal void AddPrimaryKeyToquery(DataQuery<T> query, T entity)
        {
            var primaryKeyColumns = Map.GetPrimaryKeyColumns();
            foreach (var column in primaryKeyColumns)
            {
                query.Add(column.Column, column.SqlType, ReflectionHelper.GetMemberValue(column.MemberInfoTree, entity));
            }

            if (primaryKeyColumns.Count == 0)
                throw new Exception("No primary key defined on mapping. Add at least on member mapped with Id().");
        }

        internal bool IsInsert(T entity)
        {
            var primaryKeyColumns = Map.GetPrimaryKeyColumns();
            var identityColumn = primaryKeyColumns.FirstOrDefault(x => x.IsIdentity);
            if (identityColumn == null)
                throw new Exception(@"No identity primary key column defined on mapping. Cannot determine if action is update or insert. 
Please map identity primary key column using Map.Id(). Otherwise use Insert or Update explicitly.");
            var currentIdentityValue = ReflectionHelper.GetMemberValue(identityColumn.MemberInfoTree, entity);
            return currentIdentityValue == null || currentIdentityValue as int? == 0;
        }

        /// <summary>
        /// Inserts or updates <paramref name="entity"/> in the database, based on primary key for <typeparamref name="T"/>. If the primary key is 0 or less, an insert is performed. Otherwise an update is performed.
        /// </summary>
        /// <param name="entity"></param>
        public void Save(T entity)
        {            
            if (IsInsert(entity))
                Insert(entity);
            else
                Update(entity);

        }

        /// <summary>
        /// Inserts or updates <paramref name="entity"/> in the database, based on primary key for <typeparamref name="T"/>. If the primary key is 0 or less, an insert is performed. Otherwise an update is performed.
        /// </summary>
        /// <param name="entity"></param>        
        public async Task SaveAsync(T entity)
        {
            await SaveAsync(entity, CancellationToken.None).ConfigureAwait(false);
        }

        /// <summary>
        /// Inserts or updates <paramref name="entity"/> in the database, based on primary key for <typeparamref name="T"/>. If the primary key is 0 or less, an insert is performed. Otherwise an update is performed.
        /// </summary>
        /// <param name="entity"></param>
        /// <param name="cancellationToken"></param>
        public async Task SaveAsync(T entity, CancellationToken cancellationToken)
        {
            if (IsInsert(entity))
                await InsertAsync(entity, false, cancellationToken).ConfigureAwait(false);
            else
                await UpdateAsync(entity, cancellationToken).ConfigureAwait(false);

        }

        /// <summary>
        /// Creates an instance of <see cref="DataQuery{T}" /> that can be used with <see cref="FetchSingle(int)"/> and <see cref="FetchSingleAsync(int)"/>.         
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        protected DataQuery<T> CreateFetchSinglequery(int id)
        {
            var primaryKeyColumns = Map.GetPrimaryKeyColumns();
            if (primaryKeyColumns.Count != 1)
                throw new Exception("Mapping does not have one and only one primary key column.");
            var primaryKeyColumn = primaryKeyColumns[0];            

            var query = new DataQuery<T>(Map);
            query.Add(primaryKeyColumn.Column, SqlDbType.Int, id);
            return query;
        }

        /// <summary>
        /// Fetches a single record from the database, using <paramref name="id"/> to build a where clause on <typeparamref name="T"/>'s primary key.
        /// Only works if the mapping for <typeparamref name="T"/> has one and only one primary key column and it is mapped to <see cref="int"/>.
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        public T FetchSingle(int id)
        {
            var query = CreateFetchSinglequery(id);

            return FetchSingle(query);
        }        

        /// <summary>
        /// Fetches a single record from the database, using the query provided by <paramref name="sqlText"/>. 
        /// </summary>        
        /// <param name="sqlText"></param>
        /// <returns></returns>
        public T FetchSingle(string sqlText)
        {
            return FetchSingle(sqlText, null);
        }

        /// <summary>
        /// Fetches a single record from the database, using <paramref name="query"/> to build a where clause for <typeparamref name="T"/>.
        /// </summary>
        /// <param name="query"></param>
        /// <returns></returns>
        public T FetchSingle(DataQuery<T> query)
        {
            return FetchSingle(null, query);
        }

        /// <summary>
        /// Fetches a single record from the database, using the query provided by <paramref name="sqlText"/>. Parameters used in <paramref name="sqlText"/> can be set on <paramref name="query"/>.
        /// </summary>
        /// <param name="query"></param>
        /// <param name="sqlText"></param>
        /// <returns></returns>
        public T FetchSingle(string sqlText, DataQuery<T> query)
        {
            var statement = SqlStatementGenerator.GenerateSqlStatment<T>(DMLStatementType.Select, SqlStatementResultCardinality.SingleRow, Map, query, sqlText);            

            //execute and get response
            var statementResult = ExecuteSqlStatement<T>(statement);

            //return result
            return statementResult.SingleResult;            
        }        

        /// <summary>
        /// Fetches a single record from the database, using <paramref name="id"/> to build a where clause on <typeparamref name="T"/>'s primary key.
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        public async Task<T> FetchSingleAsync(int id)
        {
            var query = CreateFetchSinglequery(id);

            return await FetchSingleAsync(query).ConfigureAwait(false);
        }

        /// <summary>
        /// Fetches a single record from the database, using <paramref name="query"/> to build a where clause for <typeparamref name="T"/>.
        /// </summary>
        /// <param name="query"></param>
        /// <returns></returns>
        public async Task<T> FetchSingleAsync(DataQuery<T> query)
        {
            return await FetchSingleAsync(null, query).ConfigureAwait(false);
        }

        /// <summary>
        /// Fetches a single record from the database, using the query provided by <paramref name="sqlText"/>. 
        /// </summary>        
        /// <param name="sqlText"></param>
        /// <returns></returns>
        public async Task<T> FetchSingleAsync(string sqlText)
        {
            return await FetchSingleAsync(sqlText, null).ConfigureAwait(false);
        }

        /// <summary>
        /// Fetches a single record from the database, using the query provided by <paramref name="sqlText"/>. Parameters used in <paramref name="sqlText"/> can be set on <paramref name="query"/>.
        /// </summary>
        /// <param name="query"></param>
        /// <param name="sqlText"></param>
        /// <returns></returns>
        public async Task<T> FetchSingleAsync(string sqlText, DataQuery<T> query)
        {
            return await FetchSingleAsync(sqlText, query, CancellationToken.None).ConfigureAwait(false);
        }

        /// <summary>
        /// Fetches a single record from the database, using the query provided by <paramref name="sqlText"/>. Parameters used in <paramref name="sqlText"/> can be set on <paramref name="query"/>.
        /// </summary>
        /// <param name="query"></param>
        /// <param name="sqlText"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        public async Task<T> FetchSingleAsync(string sqlText, DataQuery<T> query, CancellationToken cancellationToken)
        {
            var statement = SqlStatementGenerator.GenerateSqlStatment<T>(DMLStatementType.Select, SqlStatementResultCardinality.SingleRow, Map, query, sqlText);            

            //execute and get response
            var statementResult = await ExecuteSqlStatementAsync<T>(statement, cancellationToken).ConfigureAwait(false);

            //return result
            return statementResult.SingleResult;
        }
                
        /// <summary>
        /// Updates the record <paramref name="entity"/> in the database.
        /// </summary>
        /// <returns></returns>
        public void Update(T entity)
        {
            List<WhereCondition> whereColumns = new List<WhereCondition>();
            var query = new DataQuery<T>(Map);            
            AddPrimaryKeyToquery(query, entity);
            Update(entity, query);
        }

        /// <summary>
        /// Updates records in the database for <paramref name="query"/> using the values on <paramref name="entity"/>.
        /// </summary>
        /// <param name="entity"></param>
        /// <param name="query"></param>
        public void Update(T entity, DataQuery<T> query)
        {
            //generate sql statement
            var sqlStatement = SqlStatementGenerator.GenerateSqlStatment<T>(DMLStatementType.Update, SqlStatementResultCardinality.None, Map, query, null, entity, false);

            //execute statement
            ExecuteSqlStatement<object>(sqlStatement);            
        }

        /// <summary>
        /// Updates the record <paramref name="entity"/> in the database.
        /// </summary>
        /// <returns></returns>
        public async Task UpdateAsync(T entity)
        {   
            await UpdateAsync(entity, CancellationToken.None).ConfigureAwait(false);
        }

        /// <summary>
        /// Updates the record <paramref name="entity"/> in the database.
        /// </summary>
        /// <returns></returns>
        public async Task UpdateAsync(T entity, CancellationToken cancellationToken)
        {
            List<WhereCondition> whereColumns = new List<WhereCondition>();
            var query = new DataQuery<T>(Map);            
            AddPrimaryKeyToquery(query, entity);
            await UpdateAsync(entity, query, cancellationToken).ConfigureAwait(false);
        }        

        /// <summary>
        /// Updates records in the database for <paramref name="query"/> using the values on <paramref name="entity"/>.
        /// </summary>
        /// <param name="entity"></param>
        /// <param name="query"></param>
        /// <param name="cancellationToken"></param>
        public async Task UpdateAsync(T entity, DataQuery<T> query, CancellationToken cancellationToken)
        {
            //generate sql statement
            var sqlStatement = SqlStatementGenerator.GenerateSqlStatment<T>(DMLStatementType.Update, SqlStatementResultCardinality.None, Map, query, null, entity, false);

            //execute statement
            await ExecuteSqlStatementAsync<object>(sqlStatement, cancellationToken).ConfigureAwait(false);
        }

        internal void ApplyIdentityColumnToEntity(T entity, int identityValue)
        {
            
                var identityColumn = Map.Items.FirstOrDefault(x => x.IsIdentity);            
                if (identityValue > 0 && identityColumn != null)
                    ReflectionHelper.SetMemberValue(identityColumn.MemberInfoTree, identityValue, entity);
            
        }        

        /// <summary>
        /// Inserts <typeparamref name="T"/> in the database.
        /// </summary>        
        public void Insert(T entity)
        {
            Insert(entity, false);
        }

        /// <summary>
        /// Inserts <typeparamref name="T"/> in the database.
        /// </summary>
        /// <param name="entity"></param>
        /// <param name="isIdentityInsert">When false, the primary key is set by the database. If true, an identity insert is performed</param>
        /// <returns></returns>
        public void Insert(T entity, bool isIdentityInsert)
        {
            //generate insert statement
            var sqlStatement = SqlStatementGenerator.GenerateSqlStatment<T>(DMLStatementType.Insert, SqlStatementResultCardinality.SingleRow, Map, null, null, entity, isIdentityInsert);

            //execute and get response
            var response = ExecuteSqlStatement<int>(sqlStatement);

            //if response contains a value map it to the idenity column
            if(response.SingleResult > 0)
            {
                ApplyIdentityColumnToEntity(entity, response.SingleResult);
            }           
        }

        /// <summary>
        /// Inserts a new record for <typeparamref name="T"/> in the database if no record exists for the same primary key. Else the existing record is updated.
        /// </summary>        
        public void InsertOrUpdate(T entity)
        {
            InsertOrUpdate(entity, false);
        }

        /// <summary>
        /// Inserts a new record for <typeparamref name="T"/> in the database if no record exists for the same primary key. Else the existing record is updated.
        /// </summary>        
        public void InsertOrUpdate(T entity, bool isIdentityInsert)
        {
            var query = new DataQuery<T>();
            //generate query condition for primary key
            AddPrimaryKeyToquery(query, entity);

            //generate sql statement
            var statement = SqlStatementGenerator.GenerateSqlStatment<T>(DMLStatementType.InsertOrUpdate, SqlStatementResultCardinality.SingleRow, Map, query, null, entity, isIdentityInsert);

            //execute
            var response = ExecuteSqlStatement<int>(statement);

            //if response contains a value map it to the idenity column
            if (response.SingleResult > 0)
            {
                ApplyIdentityColumnToEntity(entity, response.SingleResult);
            }            
        }

        /// <summary>
        /// Inserts a new record for <typeparamref name="T"/> in the database if no record exists for the same primary key. Else the existing record is updated.
        /// </summary>        
        public async Task InsertOrUpdateAsync(T entity)
        {
            await InsertOrUpdateAsync(entity, false, CancellationToken.None).ConfigureAwait(false);
        }

        /// <summary>
        /// Inserts a new record for <typeparamref name="T"/> in the database if no record exists for the same primary key. Else the existing record is updated.
        /// </summary>        
        public async Task InsertOrUpdateAsync(T entity, bool isIdentityInsert, CancellationToken cancellationToken)
        {
            var query = new DataQuery<T>();
            //generate query condition for primary key
            AddPrimaryKeyToquery(query, entity);

            //generate sql statement
            var statement = SqlStatementGenerator.GenerateSqlStatment<T>(DMLStatementType.InsertOrUpdate, SqlStatementResultCardinality.SingleRow, Map, query, null, entity, isIdentityInsert);

            //execute
            var response = await ExecuteSqlStatementAsync<int>(statement, cancellationToken).ConfigureAwait(false);

            //if response contains a value map it to the idenity column
            if (response.SingleResult > 0)
            {
                ApplyIdentityColumnToEntity(entity, response.SingleResult);
            }            
        }


        /// <summary>
        /// Inserts <typeparamref name="T"/> in the database.
        /// </summary>
        /// <param name="entity"></param>        
        /// <returns></returns>
        public async Task InsertAsync(T entity)
        {
            await InsertAsync(entity, false, CancellationToken.None).ConfigureAwait(false);
        }

        /// <summary>
        /// Inserts <typeparamref name="T"/> in the database.
        /// </summary>
        /// <param name="entity"></param>
        /// <param name="isIdentityInsert">When false, the primary key is set by the database. If true, an identity insert is performed.</param>
        /// <returns></returns>
        public async Task InsertAsync(T entity, bool isIdentityInsert)
        {
            await InsertAsync(entity, isIdentityInsert, CancellationToken.None).ConfigureAwait(false);
        }

        /// <summary>
        /// Inserts <typeparamref name="T"/> in the database.
        /// </summary>
        /// <param name="entity"></param>
        /// <param name="isIdentityInsert">When false, the primary key is set by the database. If true, an identity insert is performed.</param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        public async Task InsertAsync(T entity, bool isIdentityInsert, CancellationToken cancellationToken)
        {
            //generate insert statement
            var sqlStatement = SqlStatementGenerator.GenerateSqlStatment<T>(DMLStatementType.Insert, SqlStatementResultCardinality.SingleRow, Map, null, null, entity, isIdentityInsert);

            //execute and get response
            var response = await ExecuteSqlStatementAsync<int>(sqlStatement, cancellationToken).ConfigureAwait(false);

            //if response contains a value map it to the idenity column
            if (response.SingleResult > 0)
            {
                ApplyIdentityColumnToEntity(entity, response.SingleResult);
            }
        }

        /// <summary>
        /// Fetches all records from the database.
        /// </summary>        
        /// <returns></returns>
        public List<T> FetchAll()
        {
            return FetchAll(null, null);
        }

        /// <summary>
        /// Fetches all records from the database for <paramref name="sqlText"/>.
        /// </summary>
        /// <param name="sqlText"></param>        
        /// <returns></returns>
        public List<T> FetchAll(string sqlText)
        {
            return FetchAll(sqlText, null);
        }

        /// <summary>
        /// Fetches all records from the database, using <paramref name="query"/> to build a where clause
        /// </summary>
        /// <param name="query"></param>
        /// <returns></returns>
        public List<T> FetchAll(DataQuery<T> query)
        {
            return FetchAll(null, query);
        }

        /// <summary>
        /// Fetches all records from the database for <paramref name="sqlText"/>, using parameters set on <paramref name="query"/>
        /// </summary>
        /// <param name="sqlText"></param>
        /// <param name="query"></param>
        /// <returns></returns>
        public List<T> FetchAll(string sqlText, DataQuery<T> query)
        {
            //generate the sql statement
            var statementType = DMLStatementType.Select;
            if (!string.IsNullOrWhiteSpace(sqlText))
                statementType = DMLStatementType.CustomQuery;
            var statement = SqlStatementGenerator.GenerateSqlStatment(statementType, SqlStatementResultCardinality.MultipleRows, Map, query, sqlText);

            //execute and get response
            var statementResult = ExecuteSqlStatement<T>(statement);

            //if total number of rows is set apply it to the query's paging object
            if (query?.Paging != null && statementResult.TotalNumberOfRows.HasValue)
            {
                query.Paging.TotalNumberOfRows = statementResult.TotalNumberOfRows;
                if (query.Paging.NumberOfRows > 0)
                {
                    query.Paging.TotalNumberOfPages = (int)Math.Ceiling((double)query.Paging.TotalNumberOfRows.Value / query.Paging.NumberOfRows);
                }
            }
            //return result
            return statementResult.MultipleResults;
        }

        /// <summary>
        /// Fetches all records from the database.
        /// </summary>        
        /// <returns></returns>
        public async Task<List<T>> FetchAllAsync()
        {
            return await FetchAllAsync(CancellationToken.None).ConfigureAwait(false); 
        }

        /// <summary>
        /// Fetches all records from the database.
        /// </summary>        
        /// <returns></returns>
        public async Task<List<T>> FetchAllAsync(CancellationToken cancellationToken)
        {
            return await FetchAllAsync(null, null, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Fetches all records from the database for <paramref name="sqlText"/>.
        /// </summary>        
        /// <returns></returns>
        public async Task<List<T>> FetchAllAsync(string sqlText)
        {
            return await FetchAllAsync(sqlText, null, CancellationToken.None).ConfigureAwait(false);
        }

        /// <summary>
        /// Fetches all records from the database for <paramref name="sqlText"/>.
        /// </summary>        
        /// <returns></returns>
        public async Task<List<T>> FetchAllAsync(string sqlText, CancellationToken cancellationToken)
        {
            return await FetchAllAsync(sqlText, null, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Fetches all records from the database, using <paramref name="query"/> to build a where clause
        /// </summary>
        /// <param name="query"></param>
        /// <returns></returns>
        public async Task<List<T>> FetchAllAsync(DataQuery<T> query)
        {
            return await FetchAllAsync(null, query, CancellationToken.None).ConfigureAwait(false);
        }

        /// <summary>
        /// Fetches all records from the database, using <paramref name="query"/> to build a where clause
        /// </summary>        
        /// <returns></returns>
        public async Task<List<T>> FetchAllAsync(DataQuery<T> query, CancellationToken cancellationToken)
        {
            return await FetchAllAsync(null, query, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Fetches all records from the database for <paramref name="sqlText"/>, using parameters set on <paramref name="query"/>
        /// </summary>
        /// <param name="sqlText"></param>
        /// <param name="query"></param>
        /// <returns></returns>
        public async Task<List<T>> FetchAllAsync(string sqlText, DataQuery<T> query)
        {
            return await FetchAllAsync(sqlText, query, CancellationToken.None).ConfigureAwait(false);
        }

        /// <summary>
        /// Fetches all records from the database for <paramref name="sqlText"/>, using parameters set on <paramref name="query"/>
        /// </summary>
        /// <param name="sqlText"></param>
        /// <param name="query"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        public async Task<List<T>> FetchAllAsync(string sqlText, DataQuery<T> query, CancellationToken cancellationToken)
        {
            //generate the sql statement            
            var statementType = DMLStatementType.Select;
            if (!string.IsNullOrWhiteSpace(sqlText))
                statementType = DMLStatementType.CustomQuery;
            var statement = SqlStatementGenerator.GenerateSqlStatment(statementType, SqlStatementResultCardinality.MultipleRows, Map, query, sqlText);
            
            //execute and get response
            var statementResult = await ExecuteSqlStatementAsync<T>(statement, cancellationToken).ConfigureAwait(false);

            //if total number of rows is set apply it to the query's paging object
            if (query?.Paging != null && statementResult.TotalNumberOfRows.HasValue)
            {
                query.Paging.TotalNumberOfRows = statementResult.TotalNumberOfRows;
                if (query.Paging.NumberOfRows > 0)
                {
                    query.Paging.TotalNumberOfPages = (int)Math.Ceiling((double)query.Paging.TotalNumberOfRows.Value / query.Paging.NumberOfRows);
                }
            }

            //return result
            return statementResult.MultipleResults;
        }

        

        /// <summary>
        /// Deletes <paramref name="entity"/> from the database
        /// </summary>
        /// <returns></returns>
        public void Delete(T entity)
        {
            var query = new DataQuery<T>(Map);            
            AddPrimaryKeyToquery(query, entity);
            Delete(query);
        }

        /// <summary>
        /// Deletes records from the database using a where clause defined by <paramref name="query"/>
        /// </summary>
        /// <param name="query"></param>
        /// <returns></returns>
        public void Delete(DataQuery<T> query)
        {
            //generate delete statement
            var sqlStatement = SqlStatementGenerator.GenerateSqlStatment<T>(DMLStatementType.Delete, SqlStatementResultCardinality.None, Map, query, null);

            //execute
            var result = ExecuteSqlStatement<object>(sqlStatement);
                        
        }

        /// <summary>
        /// Deletes <paramref name="entity"/> from the database
        /// </summary>
        /// <returns></returns>
        public async Task DeleteAsync(T entity)
        {            
            await DeleteAsync(entity, CancellationToken.None).ConfigureAwait(false);
        }

        /// <summary>
        /// Deletes <paramref name="entity"/> from the database
        /// </summary>
        /// <returns></returns>
        public async Task DeleteAsync(T entity, CancellationToken cancellationToken)
        {
            var query = new DataQuery<T>(Map);
            AddPrimaryKeyToquery(query, entity);
            await DeleteAsync(query, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Deletes records from the database using a where clause defined by <paramref name="query"/>
        /// </summary>
        /// <param name="query"></param>
        /// <returns></returns>
        public async Task DeleteAsync(DataQuery<T> query)
        {
            await DeleteAsync(query, CancellationToken.None).ConfigureAwait(false);
        }

        /// <summary>
        /// Deletes records from the database using a where clause defined by <paramref name="query"/>
        /// </summary>
        /// <param name="query"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        public async Task DeleteAsync(DataQuery<T> query, CancellationToken cancellationToken)
        {
            //generate delete statement
            var sqlStatement = SqlStatementGenerator.GenerateSqlStatment<T>(DMLStatementType.Delete, SqlStatementResultCardinality.None, Map, query, null);

            //execute
            var result = await ExecuteSqlStatementAsync<object>(sqlStatement, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Executes a custom SQL statement defined by <paramref name="sqlText"/> without a return value.
        /// </summary>
        /// <param name="sqlText">The SQL text.</param>
        /// <returns></returns>
        public void ExecuteNonQuery(string sqlText)
        {
            ExecuteScalar<int>(sqlText);
        }

        /// <summary>
        /// Executes a custom SQL statement defined by <paramref name="sqlText"/> without a return value.
        /// </summary>
        /// <param name="sqlText">The SQL text.</param>
        /// <returns></returns>
        public async Task ExecuteNonQueryAsync(string sqlText)
        {
            await ExecuteScalarAsync<int>(sqlText).ConfigureAwait(false);
        }

        /// <summary>
        /// Executes a custom SQL statement defined by <paramref name="sqlText"/> without a return value. Parameters can be defined on <paramref name="query"/>.
        /// </summary>
        /// <param name="sqlText"></param>
        /// <param name="query"></param>
        public void ExecuteNonQuery(string sqlText, DataQuery<T> query)
        {
            ExecuteScalar<int>(sqlText, query);
        }

        /// <summary>
        /// Executes a custom SQL statement defined by <paramref name="sqlText"/> without a return value. Parameters can be defined on <paramref name="query"/>.
        /// </summary>
        /// <param name="sqlText"></param>
        /// <param name="query"></param>
        public async Task ExecuteNonQueryAsync(string sqlText, DataQuery<T> query)
        {
            await ExecuteNonQueryAsync(sqlText, query, CancellationToken.None).ConfigureAwait(false);            
        }

        /// <summary>
        /// Executes a custom SQL statement defined by <paramref name="sqlText"/> without a return value. Parameters can be defined on <paramref name="query"/>.
        /// </summary>
        /// <param name="sqlText"></param>
        /// <param name="query"></param>
        /// <param name="cancellationToken"></param>
        public async Task ExecuteNonQueryAsync(string sqlText, DataQuery<T> query, CancellationToken cancellationToken)
        {
            await ExecuteScalarAsync<int>(sqlText, query, cancellationToken).ConfigureAwait(false);
        }


        /// <summary>
        /// Executes a custom SQL statement defined by <paramref name="sqlText"/> with a return value of <typeparamref name="TScalar"/>.
        /// </summary>
        /// <param name="sqlText">The SQL text.</param>
        /// <returns></returns>
        public TScalar ExecuteScalar<TScalar>(string sqlText)
        {
            return ExecuteScalar<TScalar>(sqlText, null);
        }

        
        /// <summary>
        /// Executes a custom SQL statement defined by <paramref name="sqlText"/> with a return value of <typeparamref name="TScalar"/>. Parameters can be defined on <paramref name="query"/>.
        /// </summary>
        /// <param name="sqlText">The SQL text.</param>        
        /// <param name="query"></param>
        /// <returns></returns>
        public TScalar ExecuteScalar<TScalar>(string sqlText, DataQuery<T> query)
        {
            //generate the sql statement
            var statement = SqlStatementGenerator.GenerateSqlStatment(DMLStatementType.CustomQuery, SqlStatementResultCardinality.SingleRow, Map, query, sqlText);

            //execute and get response
            var statementResult = ExecuteSqlStatement<TScalar>(statement);

            //return result
            return statementResult.SingleResult;
        }

        

        /// <summary>
        /// Executes a custom SQL statement defined by <paramref name="sqlText"/> with a return value of <typeparamref name="TScalar"/>.
        /// </summary>
        /// <param name="sqlText">The SQL text.</param>
        /// <returns></returns>
        public async Task<TScalar> ExecuteScalarAsync<TScalar>(string sqlText)
        {            
            return await ExecuteScalarAsync<TScalar>(sqlText, null).ConfigureAwait(false);            
        }

        /// <summary>
        /// Executes a custom SQL statement defined by <paramref name="sqlText"/> with a return value of <typeparamref name="TScalar"/>. Parameters can be defined on <paramref name="query"/>.
        /// </summary>
        /// <param name="sqlText">The SQL text.</param>        
        /// <param name="query"></param>
        /// <returns></returns>
        public async Task<TScalar> ExecuteScalarAsync<TScalar>(string sqlText, DataQuery<T> query)
        {
            return await ExecuteScalarAsync<TScalar>(sqlText, query, CancellationToken.None).ConfigureAwait(false);
        }

        /// <summary>
        /// Executes a custom SQL statement defined by <paramref name="sqlText"/> with a return value of <typeparamref name="TScalar"/>. Parameters can be defined on <paramref name="query"/>.
        /// </summary>
        /// <param name="sqlText">The SQL text.</param>        
        /// <param name="query"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        public async Task<TScalar> ExecuteScalarAsync<TScalar>(string sqlText, DataQuery<T> query, CancellationToken cancellationToken)
        {
            //generate the sql statement
            var statement = SqlStatementGenerator.GenerateSqlStatment<T>(DMLStatementType.CustomQuery, SqlStatementResultCardinality.SingleRow, Map, query, sqlText);

            //execute and get response
            var statementResult = await ExecuteSqlStatementAsync<TScalar>(statement, cancellationToken).ConfigureAwait(false);

            //return result
            return statementResult.SingleResult;
        }

        

        /// <summary>
        /// Executes a custom SQL statement defined by <paramref name="sqlText"/>. The first column of each row is added to the result. 
        /// </summary>
        /// <param name="sqlText"></param>        
        /// <returns></returns>
        public List<TResult> ExecuteSet<TResult>(string sqlText)
        {
            return ExecuteSet<TResult>(sqlText, null);
        }

        /// <summary>
        /// Executes a custom SQL statement defined by <paramref name="sqlText"/>. The first column of each row is added to the result. Parameters can be defined on <paramref name="query"/>.
        /// </summary>
        /// <param name="sqlText"></param>     
        /// <param name="query"></param>
        /// <returns></returns>
        public List<TResult> ExecuteSet<TResult>(string sqlText, DataQuery<T> query)
        {
            //generate statement
            var statement = SqlStatementGenerator.GenerateSqlStatment<T>(DMLStatementType.CustomQuery, SqlStatementResultCardinality.MultipleRows, Map, query, sqlText);

            //execute statement and map response
            var result = ExecuteSqlStatement<TResult>(statement);

            return result.MultipleResults;
        }

        /// <summary>
        /// Executes a custom SQL statement defined by <paramref name="sqlText"/>. The first column of each row is added to the result.
        /// </summary>
        /// <param name="sqlText"></param>        
        /// <returns></returns>
        public async Task<List<TResult>> ExecuteSetAsync<TResult>(string sqlText)
        {
            return await ExecuteSetAsync<TResult>(sqlText, null).ConfigureAwait(false);
        }

        /// <summary>
        /// Executes a custom SQL statement defined by <paramref name="sqlText"/>. The first column of each row is added to the result. Parameters can be defined on <paramref name="query"/>.
        /// </summary>
        /// <param name="sqlText"></param>
        /// <param name="query"></param>
        
        /// <returns></returns>
        public async Task<List<TResult>> ExecuteSetAsync<TResult>(string sqlText, DataQuery<T> query)
        {
            return await ExecuteSetAsync<TResult>(sqlText, query, CancellationToken.None).ConfigureAwait(false);
        }

        /// <summary>
        /// Executes a custom SQL statement defined by <paramref name="sqlText"/>. The first column of each row is added to the result. Parameters can be defined on <paramref name="query"/>.
        /// </summary>
        /// <param name="sqlText"></param>
        /// <param name="query"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        public async Task<List<TResult>> ExecuteSetAsync<TResult>(string sqlText, DataQuery<T> query, CancellationToken cancellationToken)
        {
            //generate statement
            var statement = SqlStatementGenerator.GenerateSqlStatment<T>(DMLStatementType.CustomQuery, SqlStatementResultCardinality.MultipleRows, Map, query, sqlText);

            //execute statement and map response
            var result = await ExecuteSqlStatementAsync<TResult>(statement, cancellationToken).ConfigureAwait(false);

            return result.MultipleResults;
        }


        /// <summary>
        /// Inserts a collection of entities of <typeparamref name="T"/> using Sql Bulk Copy. The SqlDbType defined on the column attributes is ignored. Instead, the Sql Type is derived from the .NET type of the mapped properties.
        /// A list of supported types can be found here: https://msdn.microsoft.com/en-us/library/system.data.datacolumn.datatype(v=vs.110).aspx
        /// This method supports System.Transaction.TransactionScope.
        /// Please mind that SqlBulkCopy is case sensitive with regards to column names.
        /// </summary>        
        /// <param name="entities"></param>
        public void BulkInsert(IEnumerable<T> entities)
        {
            BulkInsert(entities, false);
        }

        /// <summary>
        /// Inserts a collection of entities of <typeparamref name="T"/> using Sql Bulk Copy. The SqlDbType defined on the column attributes is ignored. Instead, the Sql Type is derived from the .NET type of the mapped properties.
        /// A list of supported types can be found here: https://msdn.microsoft.com/en-us/library/system.data.datacolumn.datatype(v=vs.110).aspx
        /// This method supports System.Transaction.TransactionScope.
        /// Please mind that SqlBulkCopy is case sensitive with regards to column names.
        /// </summary>        
        /// <param name="entities"></param>
        /// <param name="identityInsert"></param>        
        public void BulkInsert(IEnumerable<T> entities, bool identityInsert)
        {
            BulkInsert(entities, identityInsert, SqlBulkCopyOptions.Default);
        }

        /// <summary>
        /// Inserts a collection of entities of <typeparamref name="T"/> using Sql Bulk Copy. The SqlDbType defined on the column attributes is ignored. Instead, the Sql Type is derived from the .NET type of the mapped properties.
        /// A list of supported types can be found here: https://msdn.microsoft.com/en-us/library/system.data.datacolumn.datatype(v=vs.110).aspx
        /// This method supports System.Transaction.TransactionScope.
        /// Please mind that SqlBulkCopy is case sensitive with regards to column names.
        /// </summary>        
        /// <param name="entities"></param>
        /// <param name="isIdentityInsert">When false, the primary key is set by the database. If true, an identity insert is performed. The default value is false.</param>
        /// <param name="sqlBulkCopyOptions"></param>
        public void BulkInsert(IEnumerable<T> entities, bool isIdentityInsert, SqlBulkCopyOptions sqlBulkCopyOptions)
        {
            if (entities == null || entities.Count() == 0)
                return;

            var dataTable = Utility.CreateDataTableFromMap(Map, isIdentityInsert);            

            //create rows in the datatable for each entity
            foreach (var entity in entities)
            {
                var row = dataTable.NewRow();
                foreach (var databaseColumn in Map.Items.Where(x=>x.IsReadOnly == false))
                {
                    //set values in the row for each column (and only if the column exists in the table definition)
                    if (dataTable.Columns.Contains(databaseColumn.Column))
                    {
                        var value = ReflectionHelper.GetMemberValue(databaseColumn.MemberInfoTree, entity);
                        //if null, we must use DBNull
                        if (value == null)
                            value = DBNull.Value;
                        row[databaseColumn.Column] = value;
                    }
                }
                dataTable.Rows.Add(row);
            }

            //create a sql connection (this allows sqlBulkCopy to enlist in a transaction scope, because the sqlConnection automatically enlists when open is called)
            var start = DateTime.Now.Ticks;
            
            using (var sqlConnection = new SqlConnection(ConnectionString))
            {
                sqlConnection.Open();
                //insert using sqlBulkCopy
                using (var bulkCopy = new SqlBulkCopy(sqlConnection, sqlBulkCopyOptions, null))
                {
                    //set command time out if a value was explicitly defined
                    if (this.CommandTimeout.HasValue)
                    {
                        bulkCopy.BulkCopyTimeout = this.CommandTimeout.Value;
                    }

                    //we need to explicitly define a column mapping, otherwise the ordinal position of the columns in the datatable is used instead of name
                    for (int i = 0; i < dataTable.Columns.Count; i++)
                    {
                        var column = dataTable.Columns[i];
                        bulkCopy.ColumnMappings.Add(column.ColumnName, column.ColumnName);
                    }

                    bulkCopy.DestinationTableName = dataTable.TableName;
                    bulkCopy.WriteToServer(dataTable);
                }
            }
        }                
    }
}
