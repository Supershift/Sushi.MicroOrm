using Microsoft.Data.SqlClient;
using Microsoft.Extensions.Options;
using Sushi.MicroORM.Mapping;
using Sushi.MicroORM.Supporting;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Reflection;
using System.Reflection.PortableExecutable;
using System.Threading;
using System.Threading.Tasks;

namespace Sushi.MicroORM
{
    /// <summary>
    /// Retrieves database records and returns them as objects, based on provided mapping.
    /// </summary>
    /// <typeparam name="T">Type to convert database recrods to</typeparam>
    public class Connector<T> : IConnector<T> where T : new()
    {
        private readonly ConnectionStringProvider _connectionStringProvider;
        private readonly SqlStatementGenerator _sqlStatementGenerator;
        private readonly SqlExecuter _sqlExecuter;
        private readonly MicroOrmOptions _options;

        /// <summary>
        /// An object representing the mapping between <typeparamref name="T"/> and database.
        /// </summary>
        private readonly DataMap<T> _map;

        /// <summary>
        /// Initializes a new instance of the <see cref="Connector{T}"/> class.
        /// </summary>
        public Connector(
            ConnectionStringProvider connectionStringProvider,
            IOptions<MicroOrmOptions> options,
            DataMapProvider dataMapProvider,
            SqlStatementGenerator sqlStatementGenerator,
            SqlExecuter sqlExecuter)
        {
            _connectionStringProvider = connectionStringProvider;
            _options = options.Value;
            _sqlStatementGenerator = sqlStatementGenerator;
            _sqlExecuter = sqlExecuter;
            _map = dataMapProvider.GetMapForType<T>() as DataMap<T>;
        }
        
        /// <inheritdoc />
        public DataQuery<T> CreateQuery()
        {
            return new DataQuery<T>(_map);
        }

        /// <summary>
        /// Executes the <paramref name="statement"/> and returns the result generated by the execution.
        /// </summary>        
        /// <returns></returns>
        private async Task<SqlStatementResult<TResult>> ExecuteSqlStatementAsync<TResult>(SqlStatement<T> statement, string connectionString, int? commandTimeout, 
            CancellationToken cancellationToken)
        {
            // get default connection string and command timeout if none supplied
            if (connectionString == null)
            {
                connectionString = _connectionStringProvider.GetConnectionString(typeof(T));
            }
            
            if (commandTimeout == null)
            {
                commandTimeout = _options.DefaultCommandTimeOut;
            }

            var result = await _sqlExecuter.ExecuteAsync<T, TResult>(statement, connectionString, commandTimeout, _map, cancellationToken);
            return result;
        }

        internal void AddPrimaryKeyToquery(DataQuery<T> query, T entity)
        {
            var primaryKeyColumns = _map.GetPrimaryKeyColumns();
            foreach (var column in primaryKeyColumns)
            {
                query.Add(column.Column, column.SqlType, ReflectionHelper.GetMemberValue(column.MemberInfoTree, entity));
            }

            if (primaryKeyColumns.Count == 0)
                throw new Exception("No primary key defined on mapping. Add at least on member mapped with Id().");
        }

        internal bool IsInsert(T entity)
        {
            var primaryKeyColumns = _map.GetPrimaryKeyColumns();
            var identityColumn = primaryKeyColumns.FirstOrDefault(x => x.IsIdentity);
            if (identityColumn == null)
                throw new Exception(@"No identity primary key column defined on mapping. Cannot determine if action is update or insert. 
Please map identity primary key column using Map.Id(). Otherwise use Insert or Update explicitly.");
            var currentIdentityValue = ReflectionHelper.GetMemberValue(identityColumn.MemberInfoTree, entity);
            return currentIdentityValue == null || currentIdentityValue as int? == 0;
        }

        /// <inheritdoc />
        public async Task SaveAsync(T entity)
        {
            await SaveAsync(entity, CancellationToken.None).ConfigureAwait(false);
        }

        /// <inheritdoc />
        public async Task SaveAsync(T entity, CancellationToken cancellationToken)
        {
            if (IsInsert(entity))
                await InsertAsync(entity, false, cancellationToken).ConfigureAwait(false);
            else
                await UpdateAsync(entity, cancellationToken).ConfigureAwait(false);
        }

        /// <inheritdoc />
        public async Task UpdateAsync(T entity)
        {
            await UpdateAsync(entity, CancellationToken.None).ConfigureAwait(false);
        }

        /// <inheritdoc />
        public async Task UpdateAsync(T entity, CancellationToken cancellationToken)
        {
            var query = new DataQuery<T>(_map);
            AddPrimaryKeyToquery(query, entity);
            await UpdateAsync(entity, query, cancellationToken).ConfigureAwait(false);
        }

        /// <inheritdoc />
        public async Task UpdateAsync(T entity, DataQuery<T> query, CancellationToken cancellationToken)
        {
            // generate sql statement
            var sqlStatement = _sqlStatementGenerator.GenerateSqlStatment(DMLStatementType.Update, SqlStatementResultCardinality.None, _map, query, entity, false);

            // execute statement
            await ExecuteSqlStatementAsync<object>(sqlStatement, query.ConnectionString, query.CommandTimeOut, cancellationToken).ConfigureAwait(false);
        }

        internal void ApplyIdentityColumnToEntity(T entity, int identityValue)
        {
            var identityColumn = _map.Items.FirstOrDefault(x => x.IsIdentity);
            if (identityValue > 0 && identityColumn != null)
                ReflectionHelper.SetMemberValue(identityColumn.MemberInfoTree, identityValue, entity);
        }

        /// <inheritdoc />
        public async Task InsertOrUpdateAsync(T entity)
        {
            await InsertOrUpdateAsync(entity, false, CancellationToken.None).ConfigureAwait(false);
        }

        /// <inheritdoc />
        public async Task InsertOrUpdateAsync(T entity, bool isIdentityInsert, CancellationToken cancellationToken)
        {
            var query = new DataQuery<T>(_map);
            // generate query condition for primary key
            AddPrimaryKeyToquery(query, entity);

            // generate sql statement
            var statement = _sqlStatementGenerator.GenerateSqlStatment<T>(DMLStatementType.InsertOrUpdate, SqlStatementResultCardinality.SingleRow, _map, query, entity, isIdentityInsert);

            // execute
            var response = await ExecuteSqlStatementAsync<int>(statement, query.ConnectionString, query.CommandTimeOut, cancellationToken).ConfigureAwait(false);

            // if response contains a value map it to the idenity column
            if (response.SingleResult > 0)
            {
                ApplyIdentityColumnToEntity(entity, response.SingleResult);
            }
        }

        /// <inheritdoc />
        public async Task InsertAsync(T entity)
        {
            await InsertAsync(entity, false, CancellationToken.None).ConfigureAwait(false);
        }

        /// <inheritdoc />
        public async Task InsertAsync(T entity, bool isIdentityInsert)
        {
            await InsertAsync(entity, isIdentityInsert, CancellationToken.None).ConfigureAwait(false);
        }

        /// <inheritdoc />
        public async Task InsertAsync(T entity, bool isIdentityInsert, CancellationToken cancellationToken)
        {
            // generate insert statement
            var query = CreateQuery();
            var sqlStatement = _sqlStatementGenerator.GenerateSqlStatment<T>(DMLStatementType.Insert, SqlStatementResultCardinality.SingleRow, _map, query, entity, isIdentityInsert);

            // execute and get response
            var response = await ExecuteSqlStatementAsync<int>(sqlStatement, query.ConnectionString, query.CommandTimeOut, cancellationToken).ConfigureAwait(false);

            // if response contains a value map it to the idenity column
            if (response.SingleResult > 0)
            {
                ApplyIdentityColumnToEntity(entity, response.SingleResult);
            }
        }

        /// <inheritdoc />
        public async Task<T> GetFirstAsync(DataQuery<T> query)
        {
            return await GetFirstAsync(query, CancellationToken.None).ConfigureAwait(false);
        }

        /// <inheritdoc />
        public async Task<T> GetFirstAsync(DataQuery<T> query, CancellationToken cancellationToken)
        {
            var statement = _sqlStatementGenerator.GenerateSqlStatment<T>(DMLStatementType.Select, SqlStatementResultCardinality.SingleRow, _map, query);

            // execute and get response
            var statementResult = await ExecuteSqlStatementAsync<T>(statement, query.ConnectionString, query.CommandTimeOut, cancellationToken).ConfigureAwait(false);

            // return result
            return statementResult.SingleResult;
        }

        /// <inheritdoc />
        public async Task<QueryListResult<T>> GetAllAsync(DataQuery<T> query)
        {
            return await GetAllAsync(query, CancellationToken.None).ConfigureAwait(false);
        }

        /// <inheritdoc />
        public async Task<QueryListResult<T>> GetAllAsync(DataQuery<T> query, CancellationToken cancellationToken)
        {
            // generate the sql statement            
            var statementType = DMLStatementType.Select;
            if (!string.IsNullOrWhiteSpace(query.SqlQuery))
                statementType = DMLStatementType.CustomQuery;
            var statement = _sqlStatementGenerator.GenerateSqlStatment(statementType, SqlStatementResultCardinality.MultipleRows, _map, query);

            // execute and get response
            var statementResult = await ExecuteSqlStatementAsync<T>(statement, query.ConnectionString, query.CommandTimeOut, cancellationToken).ConfigureAwait(false);

            // if total number of rows is set apply it to the query's paging object
            if (query?.Paging != null && statementResult.TotalNumberOfRows.HasValue)
            {
                statementResult.MultipleResults.TotalNumberOfRows = statementResult.TotalNumberOfRows;
                if (query.Paging.NumberOfRows > 0)
                {
                    statementResult.MultipleResults.TotalNumberOfPages = (int)Math.Ceiling((double)statementResult.MultipleResults.TotalNumberOfRows.Value / query.Paging.NumberOfRows);
                }
            }

            // return result
            return statementResult.MultipleResults;
        }

        /// <inheritdoc />
        public async Task DeleteAsync(T entity)
        {
            await DeleteAsync(entity, CancellationToken.None).ConfigureAwait(false);
        }

        /// <inheritdoc />
        public async Task DeleteAsync(T entity, CancellationToken cancellationToken)
        {
            var query = new DataQuery<T>(_map);
            AddPrimaryKeyToquery(query, entity);
            await DeleteAsync(query, cancellationToken).ConfigureAwait(false);
        }

        /// <inheritdoc />
        public async Task DeleteAsync(DataQuery<T> query)
        {
            await DeleteAsync(query, CancellationToken.None).ConfigureAwait(false);
        }

        /// <inheritdoc />
        public async Task DeleteAsync(DataQuery<T> query, CancellationToken cancellationToken)
        {
            // generate delete statement
            var sqlStatement = _sqlStatementGenerator.GenerateSqlStatment<T>(DMLStatementType.Delete, SqlStatementResultCardinality.None, _map, query);

            // execute
            _ = await ExecuteSqlStatementAsync<object>(sqlStatement, query.ConnectionString, query.CommandTimeOut, cancellationToken).ConfigureAwait(false);
        }

        /// <inheritdoc />
        public async Task ExecuteNonQueryAsync(DataQuery<T> query)
        {
            await ExecuteNonQueryAsync(query, CancellationToken.None).ConfigureAwait(false);
        }

        /// <inheritdoc />
        public async Task ExecuteNonQueryAsync(DataQuery<T> query, CancellationToken cancellationToken)
        {
            await ExecuteScalarAsync<int>(query, cancellationToken).ConfigureAwait(false);
        }

        /// <inheritdoc />
        public async Task<TScalar> ExecuteScalarAsync<TScalar>(DataQuery<T> query)
        {
            return await ExecuteScalarAsync<TScalar>(query, CancellationToken.None).ConfigureAwait(false);
        }

        /// <inheritdoc />
        public async Task<TScalar> ExecuteScalarAsync<TScalar>(DataQuery<T> query, CancellationToken cancellationToken)
        {
            //generate the sql statement
            var statement = _sqlStatementGenerator.GenerateSqlStatment<T>(DMLStatementType.CustomQuery, SqlStatementResultCardinality.SingleRow, _map, query);

            //execute and get response
            var statementResult = await ExecuteSqlStatementAsync<TScalar>(statement, query.ConnectionString, query.CommandTimeOut, cancellationToken).ConfigureAwait(false);

            //return result
            return statementResult.SingleResult;
        }

        /// <inheritdoc />
        public async Task<List<TResult>> ExecuteSetAsync<TResult>(DataQuery<T> query)
        {
            return await ExecuteSetAsync<TResult>(query, CancellationToken.None).ConfigureAwait(false);
        }

        /// <inheritdoc />
        public async Task<List<TResult>> ExecuteSetAsync<TResult>(DataQuery<T> query, CancellationToken cancellationToken)
        {
            // generate statement
            var statement = _sqlStatementGenerator.GenerateSqlStatment<T>(DMLStatementType.CustomQuery, SqlStatementResultCardinality.MultipleRows, _map, query);

            // execute statement and map response
            var result = await ExecuteSqlStatementAsync<TResult>(statement, query.ConnectionString, query.CommandTimeOut, cancellationToken).ConfigureAwait(false);

            return result.MultipleResults;
        }

        /// <inheritdoc />
        public async Task BulkInsertAsync(IEnumerable<T> entities)
        {
            await BulkInsertAsync(entities, false);
        }
        
        /// <inheritdoc />      
        public async Task BulkInsertAsync(IEnumerable<T> entities, bool identityInsert)
        {
            await BulkInsertAsync(entities, identityInsert, SqlBulkCopyOptions.Default, CancellationToken.None);
        }

        /// <inheritdoc />
        public async Task BulkInsertAsync(IEnumerable<T> entities, bool isIdentityInsert, SqlBulkCopyOptions sqlBulkCopyOptions, CancellationToken cancellationToken)
        {
            if (entities?.Any() != true)
                return;

            var dataTable = Utility.CreateDataTableFromMap(_map, isIdentityInsert);

            //create rows in the datatable for each entity
            foreach (var entity in entities)
            {
                var row = dataTable.NewRow();
                foreach (var databaseColumn in _map.Items.Where(x => x.IsReadOnly == false))
                {
                    //set values in the row for each column (and only if the column exists in the table definition)
                    if (dataTable.Columns.Contains(databaseColumn.Column))
                    {
                        var value = ReflectionHelper.GetMemberValue(databaseColumn.MemberInfoTree, entity);
                        //if null, we must use DBNull
                        if (value == null)
                        {
                            value = DBNull.Value;
                        }
                        row[databaseColumn.Column] = value;
                    }
                }
                dataTable.Rows.Add(row);
            }

            //create a sql connection (this allows sqlBulkCopy to enlist in a transaction scope, because the sqlConnection automatically enlists when open is called)
            string connectionString = _connectionStringProvider.GetConnectionString(typeof(T));
            using var sqlConnection = new SqlConnection(connectionString);
            sqlConnection.Open();

            //insert using sqlBulkCopy
            using var bulkCopy = new SqlBulkCopy(sqlConnection, sqlBulkCopyOptions, null);
            
            //set command time out if a value was explicitly defined
            if (_options.DefaultCommandTimeOut.HasValue)
            {
                bulkCopy.BulkCopyTimeout = _options.DefaultCommandTimeOut.Value;
            }

            //we need to explicitly define a column mapping, otherwise the ordinal position of the columns in the datatable is used instead of name
            for (int i = 0; i < dataTable.Columns.Count; i++)
            {
                var column = dataTable.Columns[i];
                bulkCopy.ColumnMappings.Add(column.ColumnName, column.ColumnName);
            }

            bulkCopy.DestinationTableName = dataTable.TableName;
            await bulkCopy.WriteToServerAsync(dataTable, cancellationToken);
        }
    }
}
